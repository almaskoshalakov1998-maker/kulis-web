<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>Күліс — мультиплеер 2–9</title>
<style>
  :root{
    --bg:#0b7a2c; --board:#106b29; --panel:#135e27; --border:#0a4d1d;
    --text:#fff; --muted:#cfe8d5; --accent:#ffd84a; --chip:#113f21;
  }
  html,body{height:100%;}
  body{margin:0;background:#0e7c2f;color:var(--text);font-family:system-ui,Arial,sans-serif;}
  header{padding:14px 18px;background:#0b5f24;box-shadow:0 2px 0 rgba(0,0,0,.2);position:sticky;top:0;z-index:3}
  h1{margin:0;font-size:20px}
  main{max-width:1100px;margin:0 auto;padding:16px}
  .row{display:flex;gap:12px;flex-wrap:wrap}
  .card{
    width:68px;height:96px;border-radius:10px;background:#fff;color:#000;
    display:flex;align-items:center;justify-content:center;font-weight:700;
    box-shadow:0 2px 6px rgba(0,0,0,.35);border:2px solid #0006;cursor:pointer;user-select:none
  }
  .card.back{background:#1a3a27;color:#1a3a27;border-color:#0008;cursor:default}
  .card.disabled{pointer-events:none;opacity:.6}
  .wrap{background:var(--board);border:2px solid var(--border);border-radius:14px;padding:12px}
  .panel{background:var(--panel);border:1px solid #ffffff33;border-radius:12px;padding:12px}
  .label{font-weight:700;margin-bottom:6px}
  .btn{background:var(--accent);color:#000;border:none;border-radius:10px;padding:9px 14px;font-weight:800;cursor:pointer}
  .btn.secondary{background:#fff;color:#000}
  .btn.ghost{background:transparent;border:1px solid #fff;color:#fff}
  .btn:disabled{opacity:.5;cursor:not-allowed}
  #board{position:relative;margin:14px auto;max-width:980px;min-height:520px;background:var(--panel);
    border:2px solid #ffffff22;border-radius:18px;padding:10px}
  #tableCenter{
    position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);
    min-width:260px;min-height:160px;border:2px dashed #ffffff55;border-radius:16px;
    display:flex;flex-wrap:wrap;gap:14px;align-items:center;justify-content:center;padding:12px;background:#0f6226aa
  }
  #topHand{position:absolute;top:18px;left:50%;transform:translateX(-50%);display:flex;gap:10px}
  #bottomHand{position:absolute;bottom:18px;left:50%;transform:translateX(-50%);display:flex;gap:10px}
  #hud{display:flex;gap:12px;flex-wrap:wrap}
  #log{background:#083d1a;border-radius:10px;padding:10px;height:180px;overflow:auto;font-size:14px}
  .chip{display:inline-block;background:var(--chip);border:1px solid #ffffff22;border-radius:999px;padding:2px 8px;margin-right:6px}
  .tag{display:inline-block;background:#134d27;border:1px solid #ffffff33;border-radius:8px;padding:2px 6px;margin-left:6px;font-size:12px}
  .hint{color:var(--muted);font-size:13px}
  .section-title{margin:6px 0 8px;font-weight:800}
  #playersList .seat{background:#0f5e26;border:1px solid #ffffff22;border-radius:10px;padding:8px 10px}
  #playersList .you{background:#195c2f}
</style>
</head>
<body>
<header>
  <h1>Күліс — карточная игра (2–9 игроков)</h1>
</header>
<main>

  <!-- ЛОББИ -->
  <div id="lobby" class="wrap">
    <div class="row">
      <div class="panel" style="flex:2 1 360px;min-width:300px">
        <div class="section-title">Параметры стола</div>
        <div class="row">
          <div>
            <div class="label">Кол-во игроков (включая тебя):</div>
            <input id="numPlayers" type="number" min="2" max="9" value="2" style="width:90px;padding:6px;border-radius:8px;border:1px solid #fff"/>
          </div>
          <div>
            <div class="label">Ставки (мин–макс), тг:</div>
            <input id="minBet" type="number" value="100" style="width:100px;padding:6px;border-radius:8px;border:1px solid #fff"/> —
            <input id="maxBet" type="number" value="500" style="width:100px;padding:6px;border-radius:8px;border:1px solid #fff"/>
          </div>
        </div>
        <div class="hint" style="margin-top:6px">Все вносят «шар» (минимум). Торги идут по кругу, можно повышать в пределах диапазона или пасовать.</div>
      </div>
      <div class="panel" style="flex:1 1 240px;display:flex;align-items:end;justify-content:end">
        <button class="btn" id="startBtn">Создать раздачу</button>
      </div>
    </div>
  </div>

  <!-- ИГРОВОЙ СТОЛ -->
  <div id="game" class="wrap" style="display:none">
    <div id="hud" class="row">
      <div class="panel" style="flex:2 1 480px">
        <div class="label">Козырь: <span id="trumpView"></span>
          <span class="tag">левая: <span id="leftPalkaView"></span></span>
          <span class="tag">правая: <span id="rightPalkaView"></span></span>
        </div>
        <div id="status" class="hint">—</div>
      </div>
      <div class="panel" style="flex:1 1 280px">
        <div class="label">Банк: <span id="pot">0</span> тг</div>
        <div id="betInfo" class="hint">—</div>
      </div>
      <div class="panel" style="flex:1 1 280px">
        <div class="label">Участники</div>
        <div id="playersList" class="row"></div>
      </div>
    </div>

    <div id="board">
      <div id="topHand"></div>
      <div id="tableCenter"></div>
      <div id="bottomHand"></div>
    </div>

    <div class="row" style="margin-top:12px">
      <div class="panel" style="flex:2 1 520px">
        <div class="label">Журнал</div>
        <div id="log"></div>
      </div>
      <div class="panel" style="flex:1 1 280px">
        <div class="label">Действия</div>
        <div class="row">
          <button class="btn" id="btnAttack" disabled>Сходить</button>
          <button class="btn secondary" id="btnDefend" disabled>Бить</button>
          <button class="btn ghost" id="btnFold" disabled>Сдаться / Пас</button>
        </div>
        <div class="row" id="bettingControls" style="margin-top:8px;display:none">
          <input id="betInput" type="number" min="0" value="100" style="width:120px;padding:6px;border-radius:8px;border:1px solid #fff"/>
          <button class="btn" id="btnBet">Поставить</button>
          <button class="btn ghost" id="btnPass">Пас</button>
        </div>
      </div>
    </div>
  </div>

</main>

<script>
/* ======================= МОДЕЛЬ И ПРАВИЛА ======================= */
const SUITS = ["♠","♣","♥","♦"];      // пары: ♠↔♣, ♥↔♦
const PAIR  = {"♠":"♣","♣":"♠","♥":"♦","♦":"♥"};
const RANKS = ["7","9","10","J","Q","K","A"];
const NON_TRUMP_ORDER = {"7":0,"9":1,"10":2,"J":3,"Q":4,"K":5,"A":6}; // для некозырей
const CARD_POINTS = {"7":7,"9":9,"10":10,"J":10,"Q":10,"K":10,"A":11};
const fmt = c => c; // строка вида "J♣"

function makeDeck(){ const d=[]; for(const s of SUITS) for(const r of RANKS) d.push(r+s); return d; }
function shuffle(a){ for(let i=a.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [a[i],a[j]]=[a[j],a[i]]; } }
function leftPalka(tr){ return "7"+PAIR[tr]; }      // левая палка — 7 пары козыря
function rightPalka(tr){ return "7"+tr; }           // правая палка — 7 козыря
function isLeft(c,tr){ return c===leftPalka(tr); }
function isRight(c,tr){ return c===rightPalka(tr); }
function isTrump(c,tr){ return c.slice(-1)===tr || isLeft(c,tr); }

/* Порядок козырей: A(старший) > правая палка > левая палка > K > Q > J > 10 > 9 > 7-козырь
   (согласно описанию: палки старше всех козырей, но туз старше палок; правая > левая) */
function trumpPower(c,tr){
  if(!isTrump(c,tr)) return -1;
  const r=c.slice(0,-1), s=c.slice(-1);
  if(s===tr && r==="A") return 8;
  if(isRight(c,tr))     return 7;
  if(isLeft(c,tr))      return 6;
  const map={"K":5,"Q":4,"J":3,"10":2,"9":1,"7":0};
  return map[r] ?? 0;
}

function canBeat(attack, defend, tr){
  if(!attack || !defend) return false;
  const aT = isTrump(attack,tr), dT = isTrump(defend,tr);
  const aS = attack.slice(-1), dS = defend.slice(-1);
  if(!aT && dT) return true;                // козырь бьёт некозырь
  if(aT && dT)  return trumpPower(defend,tr) > trumpPower(attack,tr);
  if(!aT && !dT && aS===dS) return NON_TRUMP_ORDER[defend.slice(0,-1)] > NON_TRUMP_ORDER[attack.slice(0,-1)];
  return false;
}

function cardPointsForKulis(c,tr){ if(isLeft(c,tr)||isRight(c,tr)) return 10.5; return CARD_POINTS[c.slice(0,-1)]; }

/* КУЛИС:
   - три туза (A==туз; левая/правая палки считаются тузами для этой комбинации) — самый старший
   - три семёрки — старше обычных и козырных
   - 3 одной масти (козырной/не козырной)
   - 2 одной масти + (левая|правая) палка
   Козырной кулис старше не-козырного, даже при меньших очках.
   Очки: 7=7,9=9,10/J/Q/K=10, палки=10.5, A=11.
   При равенстве очков прав. палка > лев. палки.
*/
function detectKulis(hand,tr){
  const ranks = hand.map(c=>c.slice(0,-1));
  const suits = hand.map(c=>c.slice(-1));
  const hasL = hand.includes(leftPalka(tr));
  const hasR = hand.includes(rightPalka(tr));
  const asCount = ranks.filter(r=>r==="A").length;

  // три "туза" с заменами палками
  const asLike = asCount + (hasL?1:0) + (hasR?1:0);
  if(asLike>=3) return {exists:true, tier:4, trumpish:true, kind:"Три туза", pts:33, hasR, hasL};

  // три семёрки
  if(ranks.every(r=>r==="7")){
    const pts=hand.reduce((s,c)=>s+cardPointsForKulis(c,tr),0);
    return {exists:true, tier:3, trumpish:false, kind:"Три семёрки", pts, hasR, hasL};
  }

  // 3 одной масти
  const suitCount={}; suits.forEach(s=>suitCount[s]=(suitCount[s]||0)+1);
  const mono = Object.entries(suitCount).find(([s,c])=>c===3);
  if(mono){
    const s=mono[0]; const pts=hand.reduce((x,c)=>x+cardPointsForKulis(c,tr),0);
    const trumpish = (s===tr); // козырной кулис
    return {exists:true, tier: trumpish?2:1, trumpish, kind:"Одна масть (3)", pts, hasR, hasL};
  }

  // 2 одной масти + палка
  const pairSuit = Object.entries(suitCount).find(([s,c])=>c===2);
  if(pairSuit && (hasL||hasR)){
    const s=pairSuit[0]; const pts=hand.reduce((x,c)=>x+cardPointsForKulis(c,tr),0);
    const trumpish = (s===tr);
    return {exists:true, tier: trumpish?2:1, trumpish, kind:"2 одной масти + палка", pts, hasR, hasL};
  }

  return {exists:false, tier:0, trumpish:false, kind:"—", pts:0, hasR, hasL};
}

// сравнение кулисов: 1 если a>b, -1 если a<b, 0 если равны
function compareKulis(a,b){
  if(a.tier!==b.tier) return a.tier>b.tier?1:-1;
  // козырной старше не-козырного (на одних и тех же уровнях)
  if(a.trumpish!==b.trumpish) return a.trumpish?1:-1;
  if(a.pts!==b.pts) return a.pts>b.pts?1:-1;
  if(a.hasR!==b.hasR) return a.hasR?1:-1; // правая палка побеждает левую
  return 0;
}

/* ======================= ИГРОВОЙ СЕРВЕР (клиентская имитация) ======================= */
const $ = sel => document.querySelector(sel);
const logBox = $("#log");

function log(msg){ logBox.innerHTML += msg + "<br>"; logBox.scrollTop = logBox.scrollHeight; }
function setStatus(msg){ $("#status").textContent = msg; }
function setPot(v){ $("#pot").textContent = v; }
function setBetInfo(msg){ $("#betInfo").textContent = msg; }

let tableState = null;

function createTable(nPlayers,minBet,maxBet){
  // игрок 0 — человек; остальные — боты
  const names = ["Ты","Бот А","Бот Б","Бот В","Бот Г","Бот Д","Бот Е","Бот Ж","Бот З"];
  const players = Array.from({length:nPlayers}, (_,i)=>({
    id:i, name:names[i], chips:100000, inHand:true, folded:false, bet:0, cards:[]
  }));

  // колода и козырь
  const deck = makeDeck(); shuffle(deck);
  const trump = SUITS[Math.floor(Math.random()*SUITS.length)];
  const L = leftPalka(trump), R = rightPalka(trump);

  // сдача по 3 и «козырная карта лежит на земле до конца» (просто показываем масть)
  for(const p of players){ p.cards = deck.splice(0,3); }

  // Банк: все кидают «шар» = minBet
  let pot = minBet * players.length; players.forEach(p=>p.bet=minBet);

  tableState = {
    stage:"betting", minBet, maxBet, pot,
    deck, trump, L, R,
    players, current:1, // следующий после сдающего (сдаёт игрок 0 условно)
    topPlayer:null, bottomPlayer:players[0], // позже для финала
    attackCard:null, centerCards:[],
    lastRaise:minBet, highestBid:minBet, highestBidder:null,
    finalists:[], caller:null
  };
  renderHeader();
  renderPlayersList();
  renderHandsOnlyYou();
  renderTableCenter();
  updateBettingUI(true);
  logBox.innerHTML="";
  log(`Раздача создана. Козырь: ${tableState.trump}. Все внесли по ${minBet} тг.`);
  setStatus("Торги: делай ставку или пас.");
  setBetInfo(`Диапазон ставок: ${minBet}–${maxBet} тг`);
}

function renderHeader(){
  $("#game").style.display="block";
  $("#lobby").style.display="none";
  $("#trumpView").textContent = tableState.trump;
  $("#leftPalkaView").textContent = tableState.L;
  $("#rightPalkaView").textContent = tableState.R;
  setPot(tableState.pot);
}

function renderPlayersList(){
  const box = $("#playersList"); box.innerHTML="";
  for(const p of tableState.players){
    const d = document.createElement("div");
    d.className="seat" + (p.id===0?" you":"");
    d.innerHTML = `<div><b>${p.name}</b></div>
      <div class="hint">ставка: ${p.bet} • ${p.folded?"пас":"в игре"}</div>`;
    box.appendChild(d);
  }
}

function renderHandsOnlyYou(){
  const you = tableState.players[0];
  // bottom hand (you)
  const bottom = $("#bottomHand"); bottom.innerHTML="";
  you.cards.forEach(c=>{
    const el = document.createElement("div");
    el.className="card"; el.textContent=fmt(c);
    el.onclick = ()=>onYouClickCardDuringPlay(c);
    bottom.appendChild(el);
  });
  // top hand (opponent in final) — пока пусто/закрыто
  $("#topHand").innerHTML="";
}

function renderFinalHands(){
  // показать финальную пару (игрок 0 и соперник)
  const you = tableState.bottomPlayer;
  const opp = tableState.topPlayer;

  const bottom = $("#bottomHand"); bottom.innerHTML="";
  you.cards.forEach(c=>{
    const el = document.createElement("div"); el.className="card"; el.textContent=fmt(c);
    el.onclick = ()=>onYouClickCardDuringPlay(c);
    bottom.appendChild(el);
  });

  const top = $("#topHand"); top.innerHTML="";
  opp.cards.forEach(()=>{ const el = document.createElement("div"); el.className="card back"; el.textContent="🂠"; top.appendChild(el); });

  $("#btnFold").disabled=false;
}

function renderTableCenter(){
  const area = $("#tableCenter"); area.innerHTML="";
  for(const c of tableState.centerCards){
    const el = document.createElement("div"); el.className="card"; el.textContent=fmt(c);
    area.appendChild(el);
  }
}

function updateBettingUI(show){
  $("#bettingControls").style.display = show?"flex":"none";
  $("#btnFold").textContent = show ? "Пас" : "Сдаться";
  $("#btnAttack").disabled = true;
  $("#btnDefend").disabled = true;
  $("#btnFold").disabled = !show;
  if(show){
    $("#betInput").min = tableState.minBet;
    $("#betInput").max = tableState.maxBet;
    $("#betInput").value = Math.max(tableState.lastRaise, tableState.minBet);
  }
}

/* ======================= ТОРГИ ======================= */
function nextActivePlayer(from){
  const n = tableState.players.length;
  for(let i=1;i<=n;i++){
    const idx = (from + i) % n;
    const p = tableState.players[idx];
    if(!p.folded) return idx;
  }
  return from;
}

function countActive(){ return tableState.players.filter(p=>!p.folded).length; }

function humanBet(value){
  const me = tableState.players[0];
  if(value < tableState.minBet || value > tableState.maxBet){ log("Ставка вне диапазона."); return; }
  if(value < tableState.lastRaise){ log(`Нужно не меньше ${tableState.lastRaise}.`); return; }
  me.bet = value;
  if(value>tableState.highestBid){ tableState.highestBid=value; tableState.highestBidder=me.id; }
  log(`Ты поставил ${value}.`);
  setPot(tableState.pot); renderPlayersList();
  advanceBetting();
}

function humanPass(){
  const me = tableState.players[0];
  me.folded = true;
  log("Ты пасовал.");
  renderPlayersList();
  advanceBetting();
}

function botBetLogic(p){
  const k = detectKulis(p.cards, tableState.trump);
  // примитивная оценка силы руки для бота
  let strength = k.exists ? (k.tier*10 + (k.trumpish?3:0) + Math.min(5, Math.floor(k.pts))) :
    p.cards.reduce((s,c)=>s + (isTrump(c,tableState.trump)?2:0) + NON_TRUMP_ORDER[c.slice(0,-1)]/10, 0);
  // решаем: пасовать, уравнять, приподнять
  const desire = strength >= 16 ? "raise" : strength >= 10 ? "call" : "fold";
  let bid = tableState.lastRaise;
  if(desire==="fold"){ p.folded=true; log(`${p.name} пасовал.`); return; }
  if(desire==="raise"){
    bid = Math.min(tableState.maxBet, Math.max(tableState.lastRaise, tableState.minBet) + 50);
  }
  p.bet = bid;
  if(bid>tableState.highestBid){ tableState.highestBid=bid; tableState.highestBidder=p.id; }
  log(`${p.name} поставил ${bid}.`);
}

function startBettingTurn(){
  setStatus("Торги: делай ставку или пас.");
  updateBettingUI(true);
  setBetInfo(`Текущий минимум: ${tableState.lastRaise}, максимум: ${tableState.maxBet}. Активных игроков: ${countActive()}.`);
  if(tableState.current!==0){
    // ход бота
    const p = tableState.players[tableState.current];
    if(!p.folded) botBetLogic(p);
    renderPlayersList();
    // обновить требуемый минимум (уравнять максимум)
    tableState.lastRaise = Math.max(tableState.lastRaise, tableState.highestBid);
    tableState.current = nextActivePlayer(tableState.current);
    setTimeout(checkBettingEnd, 350);
  }
}

function advanceBetting(){
  // человек походил; обновим минималку
  tableState.lastRaise = Math.max(tableState.lastRaise, tableState.highestBid);
  tableState.current = nextActivePlayer(tableState.current);
  checkBettingEnd();
}

function checkBettingEnd(){
  const active = tableState.players.filter(p=>!p.folded);
  if(active.length===1){
    // единственный неуравнённый — забирает банк
    const winner = active[0]; log(`Никто не сравнял. ${winner.name} забирает банк ${tableState.pot} тг.`);
    endHand(winner.id);
    return;
  }
  // проверим, есть ли две последние ставки, которые уравнялись (все остальные пасанули)
  // условие: активных 2 → ставки должны быть равны; кто уравнял — ходит первым
  if(active.length===2){
    const [a,b] = active;
    if(a.bet===b.bet){
      tableState.finalists = [a.id,b.id];
      tableState.caller = (a.id===tableState.highestBidder ? b.id : a.id); // уравнявший
      log(`В финале: ${tableState.players[a.id].name} vs ${tableState.players[b.id].name}. Ходит уравнявший: ${tableState.players[tableState.caller].name}.`);
      startFinal();
      return;
    }
  }
  // продолжаем торги
  startBettingTurn();
}

/* ======================= ПЕРЕХОД К ФИНАЛУ ======================= */
function startFinal(){
  tableState.stage="final";
  updateBettingUI(false);
  // назначим нижнего = человек, верхнего = соперник (если финале нет человека — просто покажем ботовую дуэль)
  const [p1,p2] = tableState.finalists;
  const caller = tableState.caller;

  // раскладываем: в визуале снизу — человек, сверху — соперник (если человека нет — снизу первый финалист)
  if(p1===0 || p2===0){
    tableState.bottomPlayer = tableState.players[0];
    tableState.topPlayer = tableState.players[p1===0?p2:p1];
  }else{
    tableState.bottomPlayer = tableState.players[p1];
    tableState.topPlayer = tableState.players[p2];
  }

  // КУЛИСЫ раскрываются перед боем: сначала сдающий/раздавший? По твоему описанию: раскрывает тот, кто ходит.
  const attacker = (caller===tableState.bottomPlayer.id) ? tableState.bottomPlayer : tableState.topPlayer;
  const defender = (attacker===tableState.bottomPlayer)? tableState.topPlayer : tableState.bottomPlayer;

  const kA = detectKulis(attacker.cards, tableState.trump);
  const kD = detectKulis(defender.cards, tableState.trump);

  if(kA.exists){
    log(`➡️ ${attacker.name} раскрывает кулис: ${kA.kind} (очков: ${sumKulis(attacker.cards)})`);
    if(kD.exists){
      log(`➡️ ${defender.name} раскрывает кулис: ${kD.kind} (очков: ${sumKulis(defender.cards)})`);
      const cmp = compareKulis(kA,kD);
      if(cmp>0) return endHand(attacker.id, "Победа по кулису");
      if(cmp<0) return endHand(defender.id, "Победа по кулису");
      return splitPot("Равенство кулисов — банк делится.");
    }else{
      return endHand(attacker.id, "Мгновенная победа по кулису");
    }
  }else if(kD.exists){
    log(`➡️ ${defender.name} раскрывает кулис: ${kD.kind} (очков: ${sumKulis(defender.cards)})`);
    return endHand(defender.id, "Мгновенная победа по кулису");
  }

  // если кулисов нет — играем дуэль 3-карт (подкидной‑образная последовательность)
  tableState.centerCards=[]; renderTableCenter();
  renderFinalHands();

  // Кто ходит: уравнявший
  tableState.attackerId = caller;
  tableState.defenderId = (caller===tableState.bottomPlayer.id)? tableState.topPlayer.id : tableState.bottomPlayer.id;
  tableState.step = 0; // 0: атака1; 1: защита+контратака бота; 2: защита игрока; 3: последняя атака атакующего; 4: финальная защита
  setStatus(`${tableState.players[tableState.attackerId].name} ходит первым. Выбери карту для атаки.`);
  enableAttackIfHumanTurn();
}

function sumKulis(hand){ return hand.reduce((s,c)=>s+cardPointsForKulis(c, tableState.trump),0); }

/* ======================= ДУЭЛЬ 3 КАРТ ======================= */
function humanIsBottom(){ return tableState.bottomPlayer.id===0; }
function humanTurnToAttack(){ return tableState.attackerId===0; }
function humanTurnToDefend(){ return tableState.defenderId===0; }

function enableAttackIfHumanTurn(){
  $("#btnFold").disabled=false;
  $("#btnAttack").disabled = !humanTurnToAttack();
  $("#btnDefend").disabled = true;
}

function enableDefenseIfHumanTurn(){
  $("#btnFold").disabled=false;
  $("#btnAttack").disabled = true;
  $("#btnDefend").disabled = !humanTurnToDefend();
}

function onYouClickCardDuringPlay(card){
  if(tableState.stage!=="final") return;
  const me = tableState.players[0];
  if(humanTurnToAttack()){
    // АТАКА
    playAttack(me, card);
  }else if(humanTurnToDefend()){
    // ЗАЩИТА
    const atk = tableState.centerCards[tableState.centerCards.length-1];
    if(!canBeat(atk, card, tableState.trump)){ log("Этой картой нельзя побить."); return; }
    removeCard(me.cards, card);
    tableState.centerCards.push(card); renderTableCenter(); renderFinalHands();
    log(`Ты бьёшь ${atk} картой ${card}.`);
    // переходим к последующей логике
    afterDefenseByHuman();
  }
}

// утилиты
function removeCard(arr, c){ const i=arr.indexOf(c); if(i>=0) arr.splice(i,1); }
function chooseMinDefense(hand, atk, tr){
  const opts = hand.filter(c=>canBeat(atk,c,tr));
  if(opts.length===0) return null;
  // минимально достаточная
  return opts.sort((a,b)=>{
    const aT=isTrump(a,tr), bT=isTrump(b,tr), atkT=isTrump(atk,tr);
    if(atkT) return trumpPower(a,tr)-trumpPower(b,tr);
    const aSame = !isTrump(a,tr) && a.slice(-1)===atk.slice(-1);
    const bSame = !isTrump(b,tr) && b.slice(-1)===atk.slice(-1);
    if(aSame!==bSame) return aSame?-1:1;
    if(aT&&bT) return trumpPower(a,tr)-trumpPower(b,tr);
    if(!aT&&!bT) return NON_TRUMP_ORDER[a.slice(0,-1)]-NON_TRUMP_ORDER[b.slice(0,-1)];
    return 0;
  })[0];
}
function chooseBotAttack(hand,tr){
  if(hand.length===0) return null;
  const score = c=>{
    const t=isTrump(c,tr); const r=c.slice(0,-1);
    let base = t? 100+trumpPower(c,tr) : NON_TRUMP_ORDER[r];
    if(r==="A") base+=10; if(isLeft(c,tr)||isRight(c,tr)) base+=8;
    return base;
  };
  return hand.slice().sort((a,b)=>score(a)-score(b))[0];
}

function playAttack(playerObj, card){
  removeCard(playerObj.cards, card);
  tableState.centerCards.push(card);
  renderTableCenter(); renderFinalHands();
  log(`${playerObj.name} ходит ${card}.`);
  // защитник отвечает
  const defender = tableState.players[tableState.defenderId];
  setTimeout(()=>botOrHumanDefend(defender, card), 300);
}

function botOrHumanDefend(defender, atkCard){
  if(defender.id===0){
    // человек — включаем защиту
    setStatus("Нужно побить карту соперника.");
    enableDefenseIfHumanTurn();
    return;
  }
  const d = chooseMinDefense(defender.cards, atkCard, tableState.trump);
  if(!d){
    // не смог побить — атакующий выигрывает
    return endHand(tableState.attackerId, "Защитник не смог побить");
  }
  removeCard(defender.cards, d); tableState.centerCards.push(d);
  renderTableCenter(); renderFinalHands();
  log(`${defender.name} бьёт ${atkCard} картой ${d}.`);

  // после удачной защиты защитник СРАЗУ подкидывает свою карту (встречный ход)
  const attack2 = chooseBotAttack(defender.cards, tableState.trump);
  if(!attack2){
    // у защитника не осталось карт — атакующий побеждает
    return endHand(tableState.attackerId, "Защитник отбился, но без карт");
  }
  removeCard(defender.cards, attack2); tableState.centerCards.push(attack2);
  renderTableCenter(); renderFinalHands();
  log(`${defender.name} подкидывает ${attack2}.`);
  // теперь прежний атакующий должен побить
  const newDefId = tableState.attackerId;
  tableState.attackerId = defender.id; // роли сменились для этапа
  tableState.defenderId = newDefId;

  const newDef = tableState.players[newDefId];
  if(newDef.id===0){
    setStatus("Нужно побить подкинутую карту соперника.");
    enableDefenseIfHumanTurn();
  }else{
    // бот должен побить
    const beat = chooseMinDefense(newDef.cards, attack2, tableState.trump);
    if(!beat) return endHand(defender.id, "Атакующий не смог побить встречную карту");
    removeCard(newDef.cards, beat); tableState.centerCards.push(beat);
    renderTableCenter(); renderFinalHands();
    log(`${newDef.name} бьёт встречную ${attack2} картой ${beat}.`);

    // после этого начальный атакующий (теперь снова атакует) кладёт свою последнюю
    const attackerNow = newDef; // он отбил, теперь он атакует последней
    const last = chooseBotAttack(attackerNow.cards, tableState.trump);
    if(!last) return endHand(defender.id, "Атакующий отбил и вышел из карт");
    removeCard(attackerNow.cards, last); tableState.centerCards.push(last);
    renderTableCenter(); renderFinalHands();
    log(`${attackerNow.name} кладёт последнюю ${last}.`);

    // финальная защита у текущего защитника (defender, который подкидывал)
    const finalDefender = defender;
    const finalBeat = chooseMinDefense(finalDefender.cards, last, tableState.trump);
    if(!finalBeat) return endHand(attackerNow.id, "Финальная карта не отбита");
    removeCard(finalDefender.cards, finalBeat); tableState.centerCards.push(finalBeat);
    renderTableCenter(); renderFinalHands();
    log(`${finalDefender.name} бьёт последнюю ${last} картой ${finalBeat}.`);
    // полностью отбился → выигрывает защитник
    return endHand(finalDefender.id, "Защитник полностью отбился");
  }
}

function afterDefenseByHuman(){
  // игрок отбил встречную — теперь он должен положить свою последнюю
  const me = tableState.players[0];
  setStatus("Положи свою последнюю карту.");
  $("#btnAttack").disabled=false; // разрешим клик по карте как «атака»
}

function onSurrender(){
  if(tableState.stage==="betting"){
    humanPass();
  }else if(tableState.stage==="final"){
    const youLoseTo = tableState.players[tableState.defenderId]; // присуждаем сопернику
    endHand(youLoseTo.id, "Игрок сдался");
  }
}

function endHand(winnerId, reason=""){
  const winner = tableState.players[winnerId];
  log(`<b>Победитель: ${winner.name}</b> ${reason?`— ${reason}.`:""}`);
  setStatus(`Победитель: ${winner.name}.`);
  setPot(tableState.pot);
  $("#btnAttack").disabled=true; $("#btnDefend").disabled=true; $("#btnFold").disabled=true;
}

function splitPot(msg){
  log(`<b>${msg}</b>`);
  setStatus(msg);
  $("#btnAttack").disabled=true; $("#btnDefend").disabled=true; $("#btnFold").disabled=true;
}

/* ======================= UI КНОПКИ ======================= */
$("#startBtn").onclick = ()=>{
  const n = Math.max(2, Math.min(9, parseInt($("#numPlayers").value||"2")));
  const minB = parseInt($("#minBet").value||"100");
  const maxB = parseInt($("#maxBet").value||"500");
  createTable(n, minB, maxB);
  // запустить первый ход торгов с позиции current
  startBettingTurn();
};
$("#btnBet").onclick = ()=> humanBet(parseInt($("#betInput").value||"0"));
$("#btnPass").onclick = ()=> humanPass();
$("#btnFold").onclick = ()=> onSurrender();

// формальные кнопки (для подсказок; атака/защита делаются кликом по карте снизу)
$("#btnAttack").onclick = ()=> setStatus("Выбери карту снизу, чтобы сходить.");
$("#btnDefend").onclick = ()=> setStatus("Выбери карту снизу, чтобы бить.");

/* Подсказка при первом входе */
setTimeout(()=>{ $("#lobby").scrollIntoView({behavior:"smooth"}); }, 200);
</script>
</body>
</html>
